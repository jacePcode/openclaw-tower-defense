<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<title>Fantasy Tower Defense</title>
<style>
*{margin:0;padding:0;box-sizing:border-box}
body{background:linear-gradient(135deg,#0a0e27,#1a1a3f,#2d1b4e);font-family:Arial,sans-serif;display:flex;justify-content:center;align-items:center;min-height:100vh;color:#d4af37}
#gameContainer{position:relative;width:100%;max-width:95vw;aspect-ratio:4/3;background:linear-gradient(135deg,#0a0e27,#1a1a3f);border:3px solid #d4af37;box-shadow:0 0 30px rgba(212,175,55,.3)}
canvas{display:block;width:100%;height:100%;background:#0a0e27}
#uiContainer{position:absolute;top:0;left:0;width:100%;height:100%;pointer-events:none}
.info-panel{position:absolute;top:10px;left:10px;background:rgba(10,14,39,.9);border:2px solid #d4af37;border-radius:8px;padding:15px;color:#d4af37;font-size:14px;font-weight:bold;pointer-events:auto}
.info-text{margin:5px 0}
.modal{display:none;position:absolute;top:50%;left:50%;transform:translate(-50%,-50%);background:linear-gradient(135deg,rgba(26,26,63,.95),rgba(45,27,78,.95));border:3px solid #d4af37;border-radius:12px;padding:25px;min-width:280px;color:#d4af37;z-index:1000;pointer-events:auto}
.modal.active{display:block}
.modal-title{font-size:20px;font-weight:bold;margin-bottom:15px;border-bottom:2px solid #d4af37;padding-bottom:10px}
.modal-stat{margin:10px 0;font-size:14px;display:flex;justify-content:space-between}
.modal-buttons{margin-top:20px;display:flex;gap:10px}
.btn{flex:1;padding:12px;border:2px solid #d4af37;background:linear-gradient(135deg,rgba(212,175,55,.2),rgba(212,175,55,.1));color:#d4af37;border-radius:6px;cursor:pointer;font-weight:bold;font-size:14px;pointer-events:auto}
.btn:hover{background:linear-gradient(135deg,rgba(212,175,55,.4),rgba(212,175,55,.3))}
.btn:disabled{opacity:.5;cursor:not-allowed}
.close-btn{position:absolute;top:10px;right:10px;background:#d4af37;color:#0a0e27;border:none;border-radius:50%;width:30px;height:30px;cursor:pointer;font-weight:bold;font-size:18px;pointer-events:auto}
.overlay{position:absolute;top:0;left:0;width:100%;height:100%;background:rgba(0,0,0,.7);display:none;justify-content:center;align-items:center;z-index:999;pointer-events:auto}
.overlay.active{display:flex}
.overlay-content{background:linear-gradient(135deg,rgba(26,26,63,.95),rgba(45,27,78,.95));border:3px solid #d4af37;border-radius:12px;padding:30px;color:#d4af37;text-align:center}
.overlay-content h2{font-size:28px;margin-bottom:15px}
.overlay-content p{font-size:14px;margin:10px 0;line-height:1.6}
.gold-btn{margin-top:20px;padding:12px 30px;background:linear-gradient(135deg,#d4af37,#b8956a);color:#0a0e27;border:none;border-radius:6px;font-weight:bold;font-size:14px;cursor:pointer;pointer-events:auto}
@media(max-width:768px){#gameContainer{border:2px solid #d4af37}.info-panel{font-size:12px;padding:10px}.modal{min-width:240px;padding:20px}}
</style>
</head>
<body>
<div id="gameContainer">
<canvas id="gameCanvas"></canvas>
<div id="uiContainer">
<div class="info-panel">
<div class="info-text">üè∞ CASTLE SIEGE</div>
<div class="info-text">üí∞ <span id="gold">1000</span></div>
<div class="info-text">‚ù§Ô∏è <span id="hp">100</span></div>
<div class="info-text">üåä <span id="wave">0</span></div>
<div class="info-text">üëπ <span id="enemyCount">0</span></div>
<div class="info-text" style="font-size:11px;margin-top:10px">Press 0-3 to select tower</div>
</div>

<div id="towerMenu" class="modal">
<button class="close-btn" onclick="closeMenu()">‚úï</button>
<div class="modal-title" id="menuTitle">Tower</div>
<div class="modal-stat"><span>‚öîÔ∏è Damage:</span><span id="menuDmg">10</span></div>
<div class="modal-stat"><span>üìè Range:</span><span id="menuRange">150</span></div>
<div class="modal-stat"><span>üìä Level:</span><span id="menuLvl">1</span></div>
<div class="modal-stat"><span>üí∞ Upgrade:</span><span id="menuCost">100</span></div>
<div class="modal-buttons">
<button class="btn" id="upgradeBtn" onclick="doUpgrade()">‚¨ÜÔ∏è UPGRADE</button>
<button class="btn" onclick="closeMenu()">‚úï CLOSE</button>
</div>
</div>

<div id="startScreen" class="overlay active">
<div class="overlay-content">
<h2>‚öîÔ∏è CASTLE SIEGE ‚öîÔ∏è</h2>
<p>Defend your castle from enemy waves!</p>
<p><strong>CONTROLS:</strong></p>
<p>üñ±Ô∏è Click to place towers</p>
<p>üñ±Ô∏è Click tower to upgrade</p>
<p>Press 0-3 to select tower type</p>
<p>SPACE to pause</p>
<button class="gold-btn" onclick="startGame()">START GAME</button>
</div>
</div>

<div id="endScreen" class="overlay">
<div class="overlay-content">
<h2 id="endTitle">GAME OVER</h2>
<p>Wave: <span id="endWave">1</span></p>
<p>Gold: <span id="endGold">0</span></p>
<button class="gold-btn" onclick="location.reload()">RESTART</button>
</div>
</div>
</div>
</div>

<script>
// Game constants
const W = 1000, H = 750;
const TOWERS = {
  0: {name:"üóø Stone", cost:100, dmg:10, range:150, rate:1, upg:50, splash:0, color:"#6ba3d4"},
  1: {name:"üèπ Archer", cost:150, dmg:20, range:200, rate:1.5, upg:75, splash:0, color:"#d4a574"},
  2: {name:"üî´ Cannon", cost:200, dmg:40, range:120, rate:0.8, upg:100, splash:80, color:"#d41a1a"},
  3: {name:"üîÆ Magic", cost:250, dmg:15, range:180, rate:2, upg:125, splash:0, color:"#9d4edd"}
};
const ENEMIES = {
  SOLDIER: {name:"Soldier", hp:35, spd:1.5, gold:10, color:"#e74c3c"},
  SCOUT: {name:"Scout", hp:25, spd:3, gold:15, color:"#f39c12"},
  ORC: {name:"Orc", hp:80, spd:1, gold:25, color:"#8b6914"},
  BOSS: {name:"Boss", hp:200, spd:0.7, gold:50, color:"#2c3e50"}
};
const PATH = [
  {x:-30,y:375},{x:150,y:375},{x:250,y:250},{x:450,y:250},
  {x:450,y:450},{x:700,y:450},{x:700,y:200},{x:900,y:200},{x:1030,y:375}
];

// Game state
let G = {
  gold: 1000, hp: 100, wave: 0, 
  over: false, paused: false,
  towers: [], enemies: [], projectiles: [],
  selectedTower: 0, selectedInst: null,
  lastTime: 0, spawnTimer: 0, waveTimer: 0,
  enemiesToSpawn: [], running: false
};

// Canvas setup
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
canvas.width = W;
canvas.height = H;

// Tower class
class Tower {
  constructor(type, x, y) {
    this.type = type;
    this.x = x;
    this.y = y;
    this.lvl = 1;
    this.dmg = type.dmg;
    this.range = type.range;
    this.lastShot = 0;
  }
  
  getUpgradeCost() { return this.type.upg * this.lvl; }
  
  upgrade() {
    const cost = this.getUpgradeCost();
    if (G.gold >= cost) {
      G.gold -= cost;
      this.lvl++;
      this.dmg = Math.floor(this.type.dmg * Math.pow(1.2, this.lvl - 1));
      this.range = this.type.range + 15 * (this.lvl - 1);
      return true;
    }
    return false;
  }
  
  update(time) {
    const cooldown = 1000 / this.type.rate;
    if (time - this.lastShot < cooldown) return;
    
    // Find closest enemy in range
    let target = null, minDist = Infinity;
    for (const e of G.enemies) {
      const d = Math.hypot(e.x - this.x, e.y - this.y);
      if (d <= this.range && d < minDist) {
        minDist = d;
        target = e;
      }
    }
    
    if (target) {
      this.lastShot = time;
      G.projectiles.push(new Projectile(this.x, this.y, target, this.dmg, this.type));
    }
  }
  
  draw() {
    // Range circle if selected
    if (G.selectedInst === this) {
      ctx.beginPath();
      ctx.arc(this.x, this.y, this.range, 0, Math.PI * 2);
      ctx.fillStyle = this.type.color + '22';
      ctx.fill();
      ctx.strokeStyle = this.type.color + '88';
      ctx.lineWidth = 2;
      ctx.stroke();
    }
    
    // Tower body
    ctx.fillStyle = this.type.color;
    ctx.fillRect(this.x - 18, this.y - 18, 36, 36);
    ctx.strokeStyle = '#d4af37';
    ctx.lineWidth = 2;
    ctx.strokeRect(this.x - 18, this.y - 18, 36, 36);
    
    // Level indicator
    ctx.fillStyle = '#fff';
    ctx.font = 'bold 12px Arial';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText(this.lvl, this.x, this.y);
  }
}

// Enemy class
class Enemy {
  constructor(type) {
    this.type = type;
    this.hp = type.hp;
    this.maxHp = type.hp;
    this.x = PATH[0].x;
    this.y = PATH[0].y;
    this.pathIdx = 0;
    this.dead = false;
    this.reached = false;
  }
  
  update(dt) {
    if (this.dead || this.reached) return;
    
    // Move along path
    const target = PATH[this.pathIdx + 1];
    if (!target) {
      this.reached = true;
      G.hp--;
      return;
    }
    
    const dx = target.x - this.x;
    const dy = target.y - this.y;
    const dist = Math.hypot(dx, dy);
    
    if (dist < 5) {
      this.pathIdx++;
    } else {
      const move = this.type.spd * dt * 60;
      this.x += (dx / dist) * move;
      this.y += (dy / dist) * move;
    }
  }
  
  takeDamage(dmg) {
    this.hp -= dmg;
    if (this.hp <= 0) {
      this.dead = true;
      G.gold += this.type.gold;
      return true;
    }
    return false;
  }
  
  draw() {
    if (this.dead) return;
    
    // Body
    ctx.beginPath();
    ctx.arc(this.x, this.y, 18, 0, Math.PI * 2);
    ctx.fillStyle = this.type.color;
    ctx.fill();
    ctx.strokeStyle = '#d4af37';
    ctx.lineWidth = 2;
    ctx.stroke();
    
    // Health bar
    const barW = 36;
    const hpPct = this.hp / this.maxHp;
    ctx.fillStyle = '#333';
    ctx.fillRect(this.x - barW/2, this.y - 30, barW, 5);
    ctx.fillStyle = hpPct > 0.5 ? '#2ecc71' : hpPct > 0.25 ? '#f39c12' : '#e74c3c';
    ctx.fillRect(this.x - barW/2, this.y - 30, barW * hpPct, 5);
  }
}

// Projectile class
class Projectile {
  constructor(x, y, target, dmg, towerType) {
    this.x = x;
    this.y = y;
    this.target = target;
    this.dmg = dmg;
    this.towerType = towerType;
    this.done = false;
  }
  
  update(dt) {
    if (this.done) return;
    
    if (!this.target || this.target.dead || this.target.reached) {
      this.done = true;
      return;
    }
    
    const dx = this.target.x - this.x;
    const dy = this.target.y - this.y;
    const dist = Math.hypot(dx, dy);
    
    if (dist < 8) {
      this.hit();
      this.done = true;
    } else {
      const speed = 5 * dt * 60;
      this.x += (dx / dist) * speed;
      this.y += (dy / dist) * speed;
    }
  }
  
  hit() {
    const splash = this.towerType.splash;
    
    if (splash > 0) {
      // Splash damage
      for (const e of G.enemies) {
        const d = Math.hypot(e.x - this.x, e.y - this.y);
        if (d <= splash) {
          const dmgMult = Math.max(0.5, 1 - (d / splash) * 0.5);
          e.takeDamage(this.dmg * dmgMult);
        }
      }
    } else {
      // Single target
      this.target.takeDamage(this.dmg);
    }
  }
  
  draw() {
    if (this.done) return;
    ctx.beginPath();
    ctx.arc(this.x, this.y, 5, 0, Math.PI * 2);
    ctx.fillStyle = '#ffd700';
    ctx.fill();
  }
}

// Spawn wave
function spawnWave() {
  G.wave++;
  const count = 5 + G.wave * 2;
  const types = Object.values(ENEMIES);
  
  for (let i = 0; i < count; i++) {
    const t = types[Math.floor(Math.random() * types.length)];
    G.enemiesToSpawn.push(t);
  }
  G.spawnTimer = 0;
}

// Update UI
function updateUI() {
  document.getElementById('gold').textContent = G.gold;
  document.getElementById('hp').textContent = G.hp;
  document.getElementById('wave').textContent = G.wave;
  document.getElementById('enemyCount').textContent = G.enemies.filter(e => !e.dead && !e.reached).length;
}

// Game loop
function gameLoop(time) {
  if (!G.running) return;
  
  const dt = Math.min((time - G.lastTime) / 1000, 0.1);
  G.lastTime = time;
  
  if (!G.over && !G.paused) {
    // Spawn enemies from queue
    if (G.enemiesToSpawn.length > 0) {
      G.spawnTimer += dt;
      if (G.spawnTimer >= 0.6) {
        G.enemies.push(new Enemy(G.enemiesToSpawn.shift()));
        G.spawnTimer = 0;
      }
    }
    
    // Check for next wave
    const aliveEnemies = G.enemies.filter(e => !e.dead && !e.reached);
    if (aliveEnemies.length === 0 && G.enemiesToSpawn.length === 0) {
      G.waveTimer += dt;
      if (G.waveTimer >= 3) {
        spawnWave();
        G.waveTimer = 0;
      }
    }
    
    // Update entities
    for (const t of G.towers) t.update(time);
    for (const e of G.enemies) e.update(dt);
    for (const p of G.projectiles) p.update(dt);
    
    // Clean up
    G.enemies = G.enemies.filter(e => !e.dead && !e.reached);
    G.projectiles = G.projectiles.filter(p => !p.done);
    
    // Check game over
    if (G.hp <= 0) {
      G.over = true;
      document.getElementById('endTitle').textContent = 'üíÄ DEFEAT';
      document.getElementById('endWave').textContent = G.wave;
      document.getElementById('endGold').textContent = G.gold;
      document.getElementById('endScreen').classList.add('active');
    }
  }
  
  // Draw
  draw();
  updateUI();
  
  requestAnimationFrame(gameLoop);
}

// Draw function
function draw() {
  // Clear
  ctx.fillStyle = '#0a0e27';
  ctx.fillRect(0, 0, W, H);
  
  // Draw path
  ctx.beginPath();
  ctx.moveTo(PATH[0].x, PATH[0].y);
  for (const p of PATH) ctx.lineTo(p.x, p.y);
  ctx.strokeStyle = '#3a3a4a';
  ctx.lineWidth = 50;
  ctx.lineCap = 'round';
  ctx.lineJoin = 'round';
  ctx.stroke();
  
  // Draw path line
  ctx.strokeStyle = '#2a2a3a';
  ctx.lineWidth = 2;
  ctx.stroke();
  
  // Draw entities
  for (const t of G.towers) t.draw();
  for (const e of G.enemies) e.draw();
  for (const p of G.projectiles) p.draw();
  
  // Pause overlay
  if (G.paused) {
    ctx.fillStyle = 'rgba(0,0,0,0.5)';
    ctx.fillRect(0, 0, W, H);
    ctx.fillStyle = '#d4af37';
    ctx.font = 'bold 48px Arial';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText('PAUSED', W/2, H/2);
  }
}

// Menu functions
function openMenu(tower) {
  G.selectedInst = tower;
  document.getElementById('menuTitle').textContent = tower.type.name;
  document.getElementById('menuDmg').textContent = tower.dmg;
  document.getElementById('menuRange').textContent = tower.range;
  document.getElementById('menuLvl').textContent = tower.lvl;
  document.getElementById('menuCost').textContent = tower.getUpgradeCost();
  document.getElementById('upgradeBtn').disabled = G.gold < tower.getUpgradeCost();
  document.getElementById('towerMenu').classList.add('active');
}

function closeMenu() {
  G.selectedInst = null;
  document.getElementById('towerMenu').classList.remove('active');
}

function doUpgrade() {
  if (G.selectedInst && G.selectedInst.upgrade()) {
    openMenu(G.selectedInst);
  }
}

// Start game
function startGame() {
  document.getElementById('startScreen').classList.remove('active');
  G = {
    gold: 1000, hp: 100, wave: 0,
    over: false, paused: false,
    towers: [], enemies: [], projectiles: [],
    selectedTower: 0, selectedInst: null,
    lastTime: performance.now(), spawnTimer: 0, waveTimer: 0,
    enemiesToSpawn: [], running: true
  };
  spawnWave();
  requestAnimationFrame(gameLoop);
}

// Event listeners
canvas.addEventListener('click', (e) => {
  if (G.over || G.paused) return;
  
  const rect = canvas.getBoundingClientRect();
  const x = (e.clientX - rect.left) * (W / rect.width);
  const y = (e.clientY - rect.top) * (H / rect.height);
  
  // Check if clicking existing tower
  for (const t of G.towers) {
    if (Math.hypot(t.x - x, t.y - y) < 25) {
      openMenu(t);
      return;
    }
  }
  
  closeMenu();
  
  // Place new tower
  const type = TOWERS[G.selectedTower];
  if (G.gold >= type.cost) {
    // Check not on path
    let onPath = false;
    for (let i = 0; i < PATH.length - 1; i++) {
      const p1 = PATH[i], p2 = PATH[i+1];
      const d = distToSegment(x, y, p1.x, p1.y, p2.x, p2.y);
      if (d < 35) { onPath = true; break; }
    }
    
    if (!onPath) {
      G.towers.push(new Tower(type, x, y));
      G.gold -= type.cost;
    }
  }
});

canvas.addEventListener('touchstart', (e) => {
  e.preventDefault();
  const touch = e.touches[0];
  canvas.dispatchEvent(new MouseEvent('click', {
    clientX: touch.clientX,
    clientY: touch.clientY
  }));
});

document.addEventListener('keydown', (e) => {
  if (e.code === 'Space') {
    e.preventDefault();
    G.paused = !G.paused;
  }
  if (e.key >= '0' && e.key <= '3') {
    G.selectedTower = parseInt(e.key);
  }
  if (e.key === 'Escape') {
    closeMenu();
  }
});

// Helper: distance from point to line segment
function distToSegment(px, py, x1, y1, x2, y2) {
  const dx = x2 - x1;
  const dy = y2 - y1;
  const len2 = dx*dx + dy*dy;
  if (len2 === 0) return Math.hypot(px - x1, py - y1);
  let t = ((px - x1)*dx + (py - y1)*dy) / len2;
  t = Math.max(0, Math.min(1, t));
  return Math.hypot(px - (x1 + t*dx), py - (y1 + t*dy));
}
</script>
</body>
</html>
